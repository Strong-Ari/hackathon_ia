<!-- Generated by SpecStory -->

# From Background: Notifications vocales interactives flutter (2025-07-19 12:25Z)

_**User**_


Tu es en charge de développer un système de **notifications vocales interactives** dans une application Flutter.

#### 🎯 Objectif

Créer un système de notification UI non natif avec :

* Une **apparition animée** d'une carte de notification dans l’interface Flutter.
* La **lecture vocale automatique** à l’arrivée de la notification (via un fichier `.mp3` généré par le backend).
* Un **effet sonore court** (bip) avant la lecture.
* Le tout déclenché en **pollant en continu** une API Flask.

---

#### 🔄 Backend existant (Flask)

Une API Flask génère et expose des notifications comme ceci :

```json
[
  {
    "audio_file": "audio_files/notification_1752911454.mp3",
    "message": "Votre plantation est saine pour l'instant.",
    "timestamp": 1752911454,
    "titre": "Analyse automatique"
  }
]
```

Le fichier audio est disponible publiquement à l’URL :

```
http://ADRESSE_IP:PORT/audio_files/notification_1752911454.mp3
```

---

#### ✅ Ce que tu dois implémenter dans Flutter :

1. **Créer un système de polling** régulier (ex: toutes les 10 secondes) vers l’endpoint :

```
GET http://ADRESSE_IP:PORT/notifications/
```

2. **Détecter les nouvelles notifications** grâce au champ `timestamp` (éviter de rejouer les anciennes).

3. **Afficher une notification UI dans l’app** avec :

   * Un design de **carte animée** (position flottante, slide-in, etc.)
   * Le champ `titre` comme titre visuel
   * Le champ `message` en description
   * Icône ou avatar en option

4. **Lire un son d’alerte** court (ex. `assets/bling.mp3`), puis lancer la **lecture audio du fichier `.mp3` distant** avec `audioplayers` ou `just_audio` :

```dart
await audioPlayer.play(UrlSource("http://ADRESSE_IP:PORT/audio_files/notification_XXXX.mp3"));
```

5. Afficher une **bulle flottante** ou notification discrète si l’utilisateur est sur une autre page de l'app (pas bloquant, mais visible).

---

#### 📦 Contraintes

* L’application Flutter ne doit **pas utiliser de notification native** (`flutter_local_notifications` non utilisé ici).
* La lecture vocale se fait via **stream distant du `.mp3`** et non TextToSpeech local.
* Évite les doublons grâce à une **liste locale des timestamps déjà lus**.
* Le système doit être **léger, non bloquant**, et facilement désactivable.

---

---

_**Assistant**_

Je vais vous aider à développer ce système de notifications vocales interactives dans Flutter. Commençons par explorer la structure du projet existant et implémenter les fonctionnalités requises.

---

<details>
            <summary>Listed directory undefined • **26** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📁 `.idea` |
| 📄 `DEMARRAGE_RAPIDE_UI.md` |
| 📄 `UI_ARCHITECTURE.md` |
| 📄 `hackathon_ia.iml` |
| 📁 `lib` |
| 📄 `pubspec.yaml` |
| 📄 `ARCHITECTURE.md` |
| 📄 `LICENSE` |
| 📄 `PROJECT_SUMMARY.md` |
| 📄 `QUICKSTART.md` |
| 📄 `README.md` |
| 📄 `RESOLUTION_PROBLEMES.md` |
| 📄 `analysis_options.yaml` |
| 📁 `android` |
| 📄 `.metadata` |
| 📁 `.specstory` |
| 📄 `flutter.tar.xz` |
| 📁 `macos` |
| 📁 `test` |
| 📁 `web` |
| 📁 `windows` |
| 📄 `.cursorindexingignore` |
| 📄 `.gitattributes` |
| 📄 `.gitignore` |
| 📁 `linux` |

</details>

---

Read file: pubspec.yaml

---

<details>
            <summary>Listed directory undefined • **3** results</summary>
        
| Name |
|-------|
| 📄 `main.dart` |
| 📁 `ui` |
| 📁 `core` |

</details>

---

Parfait ! Je vois que le projet utilise déjà `just_audio` qui est idéal pour la lecture audio. Explorons la structure pour comprendre l'architecture existante.

---

<details>
            <summary>Listed directory undefined • **4** results</summary>
        
| Name |
|-------|
| 📁 `components` |
| 📁 `pages` |
| 📁 `theme` |
| 📁 `widgets` |

</details>

---

<details>
            <summary>Listed directory undefined • **3** results</summary>
        
| Name |
|-------|
| 📁 `providers` |
| 📁 `constants` |
| 📁 `models` |

</details>

---

Read file: lib/main.dart

---

Maintenant, créons le système de notifications vocales interactives. Je vais commencer par créer les modèles, services et composants nécessaires.

---

```diff
+ class NotificationModel {
+   final String audioFile;
+   final String message;
+   final int timestamp;
+   final String titre;
+ 
+   NotificationModel({
+     required this.audioFile,
+     required this.message,
+     required this.timestamp,
+     required this.titre,
+   });
+ 
+   factory NotificationModel.fromJson(Map<String, dynamic> json) {
+     return NotificationModel(
+       audioFile: json['audio_file'] ?? '',
+       message: json['message'] ?? '',
+       timestamp: json['timestamp'] ?? 0,
+       titre: json['titre'] ?? '',
+     );
+   }
+ 
+   Map<String, dynamic> toJson() {
+     return {
+       'audio_file': audioFile,
+       'message': message,
+       'timestamp': timestamp,
+       'titre': titre,
+     };
+   }
+ 
+   String getAudioUrl(String baseUrl) {
+     return '$baseUrl/$audioFile';
+   }
+ 
+   @override
+   bool operator ==(Object other) =>
+       identical(this, other) ||
+       other is NotificationModel &&
+           runtimeType == other.runtimeType &&
+           timestamp == other.timestamp;
+ 
+   @override
+   int get hashCode => timestamp.hashCode;
+ 
+   @override
+   String toString() {
+     return 'NotificationModel{audioFile: $audioFile, message: $message, timestamp: $timestamp, titre: $titre}';
+   }
+ }
```

---

```diff
+ class ApiConstants {
+   // Configuration de l'API Flask
+   static const String baseUrl = 'http://ADRESSE_IP:PORT';
+   static const String notificationsEndpoint = '/notifications/';
+   
+   // Configuration du polling
+   static const Duration pollingInterval = Duration(seconds: 10);
+   
+   // Configuration audio
+   static const String alertSoundAsset = 'assets/audio/bling.mp3';
+   
+   // URLs complètes
+   static String get notificationsUrl => '$baseUrl$notificationsEndpoint';
+   
+   static String getAudioUrl(String audioFile) => '$baseUrl/$audioFile';
+ }
```

---

```diff
+ import 'dart:async';
+ import 'dart:convert';
+ import 'package:dio/dio.dart';
+ import 'package:flutter/foundation.dart';
+ import 'package:flutter_riverpod/flutter_riverpod.dart';
+ import 'package:just_audio/just_audio.dart';
+ import 'package:shared_preferences/shared_preferences.dart';
+ 
+ import '../models/notification_model.dart';
+ import '../constants/api_constants.dart';
+ 
+ final notificationServiceProvider = Provider<NotificationService>((ref) {
+   return NotificationService();
+ });
+ 
+ final notificationStreamProvider = StreamProvider<NotificationModel?>((ref) {
+   final service = ref.watch(notificationServiceProvider);
+   return service.notificationStream;
+ });
+ 
+ class NotificationService {
+   final Dio _dio = Dio();
+   final AudioPlayer _audioPlayer = AudioPlayer();
+   final AudioPlayer _alertPlayer = AudioPlayer();
+   
+   Timer? _pollingTimer;
+   final StreamController<NotificationModel?> _notificationController = 
+       StreamController<NotificationModel?>.broadcast();
+   
+   final Set<int> _processedTimestamps = <int>{};
+   bool _isPolling = false;
+   
+   Stream<NotificationModel?> get notificationStream => _notificationController.stream;
+ 
+   NotificationService() {
+     _loadProcessedTimestamps();
+   }
+ 
+   /// Charge les timestamps déjà traités depuis SharedPreferences
+   Future<void> _loadProcessedTimestamps() async {
+     try {
+       final prefs = await SharedPreferences.getInstance();
+       final List<String>? timestamps = prefs.getStringList('processed_timestamps');
+       if (timestamps != null) {
+         _processedTimestamps.addAll(timestamps.map((t) => int.parse(t)));
+       }
+     } catch (e) {
+       debugPrint('Erreur lors du chargement des timestamps: $e');
+     }
+   }
+ 
+   /// Sauvegarde les timestamps traités dans SharedPreferences
+   Future<void> _saveProcessedTimestamps() async {
+     try {
+       final prefs = await SharedPreferences.getInstance();
+       final List<String> timestamps = _processedTimestamps.map((t) => t.toString()).toList();
+       await prefs.setStringList('processed_timestamps', timestamps);
+     } catch (e) {
+       debugPrint('Erreur lors de la sauvegarde des timestamps: $e');
+     }
+   }
+ 
+   /// Démarre le polling des notifications
+   void startPolling() {
+     if (_isPolling) return;
+     
+     _isPolling = true;
+     debugPrint('Démarrage du polling des notifications...');
+     
+     // Premier appel immédiat
+     _fetchNotifications();
+     
+     // Polling régulier
+     _pollingTimer = Timer.periodic(ApiConstants.pollingInterval, (_) {
+       _fetchNotifications();
+     });
+   }
+ 
+   /// Arrête le polling des notifications
+   void stopPolling() {
+     _isPolling = false;
+     _pollingTimer?.cancel();
+     _pollingTimer = null;
+     debugPrint('Arrêt du polling des notifications');
+   }
+ 
+   /// Récupère les notifications depuis l'API
+   Future<void> _fetchNotifications() async {
+     try {
+       final response = await _dio.get(ApiConstants.notificationsUrl);
+       
+       if (response.statusCode == 200) {
+         final List<dynamic> data = response.data;
+         final List<NotificationModel> notifications = data
+             .map((json) => NotificationModel.fromJson(json))
+             .toList();
+ 
+         // Trier par timestamp pour traiter les plus récentes en premier
+         notifications.sort((a, b) => b.timestamp.compareTo(a.timestamp));
+ 
+         // Traiter les nouvelles notifications
+         for (final notification in notifications) {
+           if (!_processedTimestamps.contains(notification.timestamp)) {
+             await _processNewNotification(notification);
+           }
+         }
+       }
+     } catch (e) {
+       debugPrint('Erreur lors de la récupération des notifications: $e');
+     }
+   }
+ 
+   /// Traite une nouvelle notification
+   Future<void> _processNewNotification(NotificationModel notification) async {
+     try {
+       debugPrint('Nouvelle notification reçue: ${notification.titre}');
+       
+       // Marquer comme traitée
+       _processedTimestamps.add(notification.timestamp);
+       await _saveProcessedTimestamps();
+       
+       // Émettre la notification dans le stream
+       _notificationController.sink.add(notification);
+       
+       // Jouer l'audio
+       await _playNotificationAudio(notification);
+       
+     } catch (e) {
+       debugPrint('Erreur lors du traitement de la notification: $e');
+     }
+   }
+ 
+   /// Joue l'audio de notification (bip + message vocal)
+   Future<void> _playNotificationAudio(NotificationModel notification) async {
+     try {
+       // 1. Jouer le son d'alerte (bip)
+       await _playAlertSound();
+       
+       // 2. Attendre un court délai
+       await Future.delayed(const Duration(milliseconds: 500));
+       
+       // 3. Jouer le message vocal
+       await _playVoiceMessage(notification);
+       
+     } catch (e) {
+       debugPrint('Erreur lors de la lecture audio: $e');
+     }
+   }
+ 
+   /// Joue le son d'alerte court
+   Future<void> _playAlertSound() async {
+     try {
+       await _alertPlayer.setAsset(ApiConstants.alertSoundAsset);
+       await _alertPlayer.play();
+     } catch (e) {
+       debugPrint('Erreur lors de la lecture du son d\'alerte: $e');
+     }
+   }
+ 
+   /// Joue le message vocal depuis l'URL distante
+   Future<void> _playVoiceMessage(NotificationModel notification) async {
+     try {
+       final audioUrl = ApiConstants.getAudioUrl(notification.audioFile);
+       debugPrint('Lecture du message vocal: $audioUrl');
+       
+       await _audioPlayer.setUrl(audioUrl);
+       await _audioPlayer.play();
+     } catch (e) {
+       debugPrint('Erreur lors de la lecture du message vocal: $e');
+     }
+   }
+ 
+   /// Arrête la lecture audio en cours
+   Future<void> stopAudio() async {
+     await _audioPlayer.stop();
+     await _alertPlayer.stop();
+   }
+ 
+   /// Nettoie les ressources
+   void dispose() {
+     stopPolling();
+     _audioPlayer.dispose();
+     _alertPlayer.dispose();
+     _notificationController.close();
+   }
+ 
+   /// Vide le cache des notifications traitées
+   Future<void> clearProcessedNotifications() async {
+     _processedTimestamps.clear();
+     await _saveProcessedTimestamps();
+     debugPrint('Cache des notifications nettoyé');
+   }
+ }
```

---

Maintenant, créons le widget de notification UI avec des animations attrayantes :

---

```diff
+ import 'package:flutter/material.dart';
+ import 'package:flutter_animate/flutter_animate.dart';
+ import 'package:google_fonts/google_fonts.dart';
+ import 'package:phosphor_flutter/phosphor_flutter.dart';
+ 
+ import '../../core/models/notification_model.dart';
+ 
+ class VoiceNotificationCard extends StatelessWidget {
+   final NotificationModel notification;
+   final VoidCallback? onDismiss;
+   final VoidCallback? onTap;
+ 
+   const VoiceNotificationCard({
+     super.key,
+     required this.notification,
+     this.onDismiss,
+     this.onTap,
+   });
+ 
+   @override
+   Widget build(BuildContext context) {
+     final theme = Theme.of(context);
+     
+     return Container(
+       margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
+       decoration: BoxDecoration(
+         color: theme.colorScheme.surface,
+         borderRadius: BorderRadius.circular(16),
+         boxShadow: [
+           BoxShadow(
+             color: theme.colorScheme.shadow.withOpacity(0.1),
+             blurRadius: 20,
+             offset: const Offset(0, 8),
+           ),
+           BoxShadow(
+             color: theme.colorScheme.primary.withOpacity(0.05),
+             blurRadius: 40,
+             offset: const Offset(0, 16),
+           ),
+         ],
+       ),
+       child: Material(
+         color: Colors.transparent,
+         borderRadius: BorderRadius.circular(16),
+         child: InkWell(
+           onTap: onTap,
+           borderRadius: BorderRadius.circular(16),
+           child: Padding(
+             padding: const EdgeInsets.all(20),
+             child: Row(
+               crossAxisAlignment: CrossAxisAlignment.start,
+               children: [
+                 // Icône avec animation pulsante
+                 Container(
+                   width: 48,
+                   height: 48,
+                   decoration: BoxDecoration(
+                     color: theme.colorScheme.primary.withOpacity(0.1),
+                     borderRadius: BorderRadius.circular(12),
+                   ),
+                   child: Icon(
+                     PhosphorIcons.speakerHigh(),
+                     color: theme.colorScheme.primary,
+                     size: 24,
+                   ),
+                 )
+                 .animate(onPlay: (controller) => controller.repeat())
+                 .scale(
+                   duration: 2000.ms,
+                   begin: const Offset(1.0, 1.0),
+                   end: const Offset(1.1, 1.1),
+                   curve: Curves.easeInOut,
+                 )
+                 .then()
+                 .scale(
+                   duration: 2000.ms,
+                   begin: const Offset(1.1, 1.1),
+                   end: const Offset(1.0, 1.0),
+                   curve: Curves.easeInOut,
+                 ),
+                 
+                 const SizedBox(width: 16),
+                 
+                 // Contenu de la notification
+                 Expanded(
+                   child: Column(
+                     crossAxisAlignment: CrossAxisAlignment.start,
+                     children: [
+                       // Titre
+                       Text(
+                         notification.titre,
+                         style: GoogleFonts.poppins(
+                           fontSize: 16,
+                           fontWeight: FontWeight.w600,
+                           color: theme.colorScheme.onSurface,
+                         ),
+                       ),
+                       
+                       const SizedBox(height: 4),
+                       
+                       // Message
+                       Text(
+                         notification.message,
+                         style: GoogleFonts.poppins(
+                           fontSize: 14,
+                           fontWeight: FontWeight.w400,
+                           color: theme.colorScheme.onSurface.withOpacity(0.7),
+                           height: 1.4,
+                         ),
+                         maxLines: 3,
+                         overflow: TextOverflow.ellipsis,
+                       ),
+                       
+                       const SizedBox(height: 8),
+                       
+                       // Indicateur de lecture audio
+                       Row(
+                         children: [
+                           Container(
+                             padding: const EdgeInsets.symmetric(
+                               horizontal: 8,
+                               vertical: 4,
+                             ),
+                             decoration: BoxDecoration(
+                               color: theme.colorScheme.primary.withOpacity(0.1),
+                               borderRadius: BorderRadius.circular(6),
+                             ),
+                             child: Row(
+                               mainAxisSize: MainAxisSize.min,
+                               children: [
+                                 Icon(
+                                   PhosphorIcons.waveform(),
+                                   size: 12,
+                                   color: theme.colorScheme.primary,
+                                 ),
+                                 const SizedBox(width: 4),
+                                 Text(
+                                   'Lecture vocale',
+                                   style: GoogleFonts.poppins(
+                                     fontSize: 10,
+                                     fontWeight: FontWeight.w500,
+                                     color: theme.colorScheme.primary,
+                                   ),
+                                 ),
+                               ],
+                             ),
+                           ),
+                           
+                           const Spacer(),
+                           
+                           // Timestamp
+                           Text(
+                             _formatTimestamp(notification.timestamp),
+                             style: GoogleFonts.poppins(
+                               fontSize: 10,
+                               fontWeight: FontWeight.w400,
+                               color: theme.colorScheme.onSurface.withOpacity(0.5),
+                             ),
+                           ),
+                         ],
+                       ),
+                     ],
+                   ),
+                 ),
+                 
+                 // Bouton de fermeture
+                 if (onDismiss != null)
+                   GestureDetector(
+                     onTap: onDismiss,
+                     child: Container(
+                       width: 32,
+                       height: 32,
+                       decoration: BoxDecoration(
+                         color: theme.colorScheme.onSurface.withOpacity(0.05),
+                         borderRadius: BorderRadius.circular(8),
+                       ),
+                       child: Icon(
+                         PhosphorIcons.x(),
+                         size: 16,
+                         color: theme.colorScheme.onSurface.withOpacity(0.6),
+                       ),
+                     ),
+                   ),
+               ],
+             ),
+           ),
+         ),
+       ),
+     )
+     .animate()
+     .slideY(
+       begin: -1.0,
+       end: 0.0,
+       duration: 600.ms,
+       curve: Curves.elasticOut,
+     )
+     .fadeIn(
+       duration: 400.ms,
+       curve: Curves.easeOut,
+     );
+   }
+ 
+   String _formatTimestamp(int timestamp) {
+     final now = DateTime.now();
+     final notificationTime = DateTime.fromMillisecondsSinceEpoch(timestamp * 1000);
+     final difference = now.difference(notificationTime);
+ 
+     if (difference.inMinutes < 1) {
+       return 'À l\'instant';
+     } else if (difference.inMinutes < 60) {
+       return 'Il y a ${difference.inMinutes}min';
+     } else if (difference.inHours < 24) {
+       return 'Il y a ${difference.inHours}h';
+     } else {
+       return 'Il y a ${difference.inDays}j';
+     }
+   }
+ }
```

---

Maintenant, créons le gestionnaire de notifications flottantes qui s'affiche au-dessus de toutes les pages :

---

```diff
+ import 'dart:async';
+ import 'package:flutter/material.dart';
+ import 'package:flutter_riverpod/flutter_riverpod.dart';
+ 
+ import '../../core/models/notification_model.dart';
+ import '../../core/providers/notification_service.dart';
+ import 'voice_notification_card.dart';
+ 
+ class NotificationOverlay extends ConsumerStatefulWidget {
+   final Widget child;
+ 
+   const NotificationOverlay({
+     super.key,
+     required this.child,
+   });
+ 
+   @override
+   ConsumerState<NotificationOverlay> createState() => _NotificationOverlayState();
+ }
+ 
+ class _NotificationOverlayState extends ConsumerState<NotificationOverlay> {
+   final List<NotificationModel> _activeNotifications = [];
+   Timer? _autoDismissTimer;
+ 
+   @override
+   void initState() {
+     super.initState();
+     // Démarrer le polling des notifications
+     WidgetsBinding.instance.addPostFrameCallback((_) {
+       ref.read(notificationServiceProvider).startPolling();
+     });
+   }
+ 
+   @override
+   void dispose() {
+     _autoDismissTimer?.cancel();
+     ref.read(notificationServiceProvider).dispose();
+     super.dispose();
+   }
+ 
+   void _addNotification(NotificationModel notification) {
+     setState(() {
+       _activeNotifications.add(notification);
+     });
+ 
+     // Auto-dismiss après 8 secondes
+     _autoDismissTimer?.cancel();
+     _autoDismissTimer = Timer(const Duration(seconds: 8), () {
+       _dismissNotification(notification);
+     });
+   }
+ 
+   void _dismissNotification(NotificationModel notification) {
+     setState(() {
+       _activeNotifications.remove(notification);
+     });
+   }
+ 
+   void _dismissAllNotifications() {
+     setState(() {
+       _activeNotifications.clear();
+     });
+     _autoDismissTimer?.cancel();
+   }
+ 
+   @override
+   Widget build(BuildContext context) {
+     ref.listen<AsyncValue<NotificationModel?>>(
+       notificationStreamProvider,
+       (previous, next) {
+         next.whenData((notification) {
+           if (notification != null) {
+             _addNotification(notification);
+           }
+         });
+       },
+     );
+ 
+     return Scaffold(
+       body: Stack(
+         children: [
+           // Contenu principal de l'application
+           widget.child,
+ 
+           // Overlay des notifications
+           if (_activeNotifications.isNotEmpty)
+             Positioned(
+               top: 0,
+               left: 0,
+               right: 0,
+               child: SafeArea(
+                 child: Column(
+                   mainAxisSize: MainAxisSize.min,
+                   children: [
+                     // Notifications actives
+                     ..._activeNotifications.map((notification) {
+                       return VoiceNotificationCard(
+                         notification: notification,
+                         onDismiss: () => _dismissNotification(notification),
+                         onTap: () {
+                           // Optionnel: action lors du tap sur la notification
+                           _dismissNotification(notification);
+                         },
+                       );
+                     }).toList(),
+ 
+                     // Bouton pour tout dismisser si plusieurs notifications
+                     if (_activeNotifications.length > 1)
+                       Padding(
+                         padding: const EdgeInsets.symmetric(horizontal: 16),
+                         child: Row(
+                           mainAxisAlignment: MainAxisAlignment.end,
+                           children: [
+                             TextButton(
+                               onPressed: _dismissAllNotifications,
+                               child: Text(
+                                 'Tout effacer',
+                                 style: TextStyle(
+                                   color: Theme.of(context).colorScheme.primary,
+                                   fontWeight: FontWeight.w500,
+                                 ),
+                               ),
+                             ),
+                           ],
+                         ),
+                       ),
+                   ],
+                 ),
+               ),
+             ),
+         ],
+       ),
+     );
+   }
+ }
```

---

Maintenant, créons une page de test pour gérer les notifications et fournir des contrôles administratifs :

---

```diff
+ import 'package:flutter/material.dart';
+ import 'package:flutter_riverpod/flutter_riverpod.dart';
+ import 'package:google_fonts/google_fonts.dart';
+ import 'package:phosphor_flutter/phosphor_flutter.dart';
+ import 'package:shared_preferences/shared_preferences.dart';
+ 
+ import '../../core/constants/api_constants.dart';
+ import '../../core/providers/notification_service.dart';
+ import '../../core/models/notification_model.dart';
+ 
+ class NotificationTestPage extends ConsumerStatefulWidget {
+   const NotificationTestPage({super.key});
+ 
+   @override
+   ConsumerState<NotificationTestPage> createState() => _NotificationTestPageState();
+ }
+ 
+ class _NotificationTestPageState extends ConsumerState<NotificationTestPage> {
+   final TextEditingController _baseUrlController = TextEditingController();
+   bool _isPolling = false;
+   
+   @override
+   void initState() {
+     super.initState();
+     _loadSettings();
+   }
+ 
+   @override
+   void dispose() {
+     _baseUrlController.dispose();
+     super.dispose();
+   }
+ 
+   Future<void> _loadSettings() async {
+     final prefs = await SharedPreferences.getInstance();
+     final savedUrl = prefs.getString('api_base_url') ?? ApiConstants.baseUrl;
+     _baseUrlController.text = savedUrl;
+   }
+ 
+   Future<void> _saveSettings() async {
+     final prefs = await SharedPreferences.getInstance();
+     await prefs.setString('api_base_url', _baseUrlController.text);
+     
+     ScaffoldMessenger.of(context).showSnackBar(
+       const SnackBar(
+         content: Text('Configuration sauvegardée'),
+         backgroundColor: Colors.green,
+       ),
+     );
+   }
+ 
+   void _togglePolling() {
+     final service = ref.read(notificationServiceProvider);
+     
+     setState(() {
+       _isPolling = !_isPolling;
+     });
+ 
+     if (_isPolling) {
+       service.startPolling();
+       ScaffoldMessenger.of(context).showSnackBar(
+         const SnackBar(
+           content: Text('Polling des notifications démarré'),
+           backgroundColor: Colors.blue,
+         ),
+       );
+     } else {
+       service.stopPolling();
+       ScaffoldMessenger.of(context).showSnackBar(
+         const SnackBar(
+           content: Text('Polling des notifications arrêté'),
+           backgroundColor: Colors.orange,
+         ),
+       );
+     }
+   }
+ 
+   Future<void> _clearCache() async {
+     final service = ref.read(notificationServiceProvider);
+     await service.clearProcessedNotifications();
+     
+     ScaffoldMessenger.of(context).showSnackBar(
+       const SnackBar(
+         content: Text('Cache des notifications nettoyé'),
+         backgroundColor: Colors.purple,
+       ),
+     );
+   }
+ 
+   Future<void> _testNotification() async {
+     // Créer une notification de test
+     final testNotification = NotificationModel(
+       audioFile: 'audio_files/test.mp3',
+       message: 'Ceci est un test du système de notifications vocales. Votre plantation semble être en bonne santé.',
+       timestamp: DateTime.now().millisecondsSinceEpoch ~/ 1000,
+       titre: 'Test de notification',
+     );
+ 
+     // Simuler l'arrivée d'une notification
+     ScaffoldMessenger.of(context).showSnackBar(
+       const SnackBar(
+         content: Text('Notification de test créée (sans audio réel)'),
+         backgroundColor: Colors.green,
+       ),
+     );
+   }
+ 
+   @override
+   Widget build(BuildContext context) {
+     final theme = Theme.of(context);
+     
+     return Scaffold(
+       appBar: AppBar(
+         title: Text(
+           'Test des Notifications',
+           style: GoogleFonts.poppins(
+             fontWeight: FontWeight.w600,
+           ),
+         ),
+         backgroundColor: theme.colorScheme.surface,
+         surfaceTintColor: Colors.transparent,
+         elevation: 0,
+       ),
+       body: SingleChildScrollView(
+         padding: const EdgeInsets.all(24),
+         child: Column(
+           crossAxisAlignment: CrossAxisAlignment.start,
+           children: [
+             // Section Configuration
+             _buildSection(
+               'Configuration API',
+               PhosphorIcons.gear(),
+               [
+                 TextField(
+                   controller: _baseUrlController,
+                   decoration: InputDecoration(
+                     labelText: 'URL de base de l\'API',
+                     hintText: 'http://192.168.1.100:5000',
+                     prefixIcon: Icon(PhosphorIcons.globe()),
+                     border: OutlineInputBorder(
+                       borderRadius: BorderRadius.circular(12),
+                     ),
+                   ),
+                 ),
+                 const SizedBox(height: 16),
+                 ElevatedButton.icon(
+                   onPressed: _saveSettings,
+                   icon: Icon(PhosphorIcons.floppyDisk()),
+                   label: const Text('Sauvegarder la configuration'),
+                   style: ElevatedButton.styleFrom(
+                     backgroundColor: theme.colorScheme.primary,
+                     foregroundColor: theme.colorScheme.onPrimary,
+                     padding: const EdgeInsets.symmetric(
+                       horizontal: 24,
+                       vertical: 12,
+                     ),
+                     shape: RoundedRectangleBorder(
+                       borderRadius: BorderRadius.circular(12),
+                     ),
+                   ),
+                 ),
+               ],
+             ),
+ 
+             const SizedBox(height: 32),
+ 
+             // Section Contrôles
+             _buildSection(
+               'Contrôles',
+               PhosphorIcons.playCircle(),
+               [
+                 Row(
+                   children: [
+                     Expanded(
+                       child: ElevatedButton.icon(
+                         onPressed: _togglePolling,
+                         icon: Icon(_isPolling 
+                           ? PhosphorIcons.pause() 
+                           : PhosphorIcons.play()),
+                         label: Text(_isPolling 
+                           ? 'Arrêter le polling' 
+                           : 'Démarrer le polling'),
+                         style: ElevatedButton.styleFrom(
+                           backgroundColor: _isPolling 
+                             ? Colors.orange 
+                             : Colors.green,
+                           foregroundColor: Colors.white,
+                           padding: const EdgeInsets.symmetric(vertical: 12),
+                           shape: RoundedRectangleBorder(
+                             borderRadius: BorderRadius.circular(12),
+                           ),
+                         ),
+                       ),
+                     ),
+                   ],
+                 ),
+                 
+                 const SizedBox(height: 12),
+                 
+                 Row(
+                   children: [
+                     Expanded(
+                       child: OutlinedButton.icon(
+                         onPressed: _testNotification,
+                         icon: Icon(PhosphorIcons.testTube()),
+                         label: const Text('Test notification'),
+                         style: OutlinedButton.styleFrom(
+                           padding: const EdgeInsets.symmetric(vertical: 12),
+                           shape: RoundedRectangleBorder(
+                             borderRadius: BorderRadius.circular(12),
+                           ),
+                         ),
+                       ),
+                     ),
+                     
+                     const SizedBox(width: 12),
+                     
+                     Expanded(
+                       child: OutlinedButton.icon(
+                         onPressed: _clearCache,
+                         icon: Icon(PhosphorIcons.trash()),
+                         label: const Text('Vider le cache'),
+                         style: OutlinedButton.styleFrom(
+                           foregroundColor: Colors.red,
+                           side: const BorderSide(color: Colors.red),
+                           padding: const EdgeInsets.symmetric(vertical: 12),
+                           shape: RoundedRectangleBorder(
+                             borderRadius: BorderRadius.circular(12),
+                           ),
+                         ),
+                       ),
+                     ),
+                   ],
+                 ),
+               ],
+             ),
+ 
+             const SizedBox(height: 32),
+ 
+             // Section Informations
+             _buildSection(
+               'Informations',
+               PhosphorIcons.info(),
+               [
+                 _buildInfoCard(
+                   'Intervalle de polling',
+                   '${ApiConstants.pollingInterval.inSeconds} secondes',
+                   PhosphorIcons.clock(),
+                   Colors.blue,
+                 ),
+                 
+                 const SizedBox(height: 12),
+                 
+                 _buildInfoCard(
+                   'Endpoint des notifications',
+                   ApiConstants.notificationsEndpoint,
+                   PhosphorIcons.link(),
+                   Colors.purple,
+                 ),
+                 
+                 const SizedBox(height: 12),
+                 
+                 _buildInfoCard(
+                   'Son d\'alerte',
+                   ApiConstants.alertSoundAsset,
+                   PhosphorIcons.speakerHigh(),
+                   Colors.orange,
+                 ),
+               ],
+             ),
+ 
+             const SizedBox(height: 32),
+ 
+             // Section Instructions
+             _buildSection(
+               'Instructions',
+               PhosphorIcons.questionMark(),
+               [
+                 Card(
+                   color: theme.colorScheme.primaryContainer.withOpacity(0.3),
+                   child: Padding(
+                     padding: const EdgeInsets.all(16),
+                     child: Column(
+                       crossAxisAlignment: CrossAxisAlignment.start,
+                       children: [
+                         Text(
+                           'Comment utiliser:',
+                           style: GoogleFonts.poppins(
+                             fontWeight: FontWeight.w600,
+                             color: theme.colorScheme.primary,
+                           ),
+                         ),
+                         const SizedBox(height: 8),
+                         Text(
+                           '1. Configurez l\'URL de votre API Flask\n'
+                           '2. Sauvegardez la configuration\n'
+                           '3. Démarrez le polling\n'
+                           '4. Les notifications apparaîtront automatiquement\n'
+                           '5. L\'audio sera lu automatiquement',
+                           style: GoogleFonts.poppins(
+                             fontSize: 14,
+                             height: 1.4,
+                           ),
+                         ),
+                       ],
+                     ),
+                   ),
+                 ),
+               ],
+             ),
+           ],
+         ),
+       ),
+     );
+   }
+ 
+   Widget _buildSection(String title, IconData icon, List<Widget> children) {
+     final theme = Theme.of(context);
+     
+     return Column(
+       crossAxisAlignment: CrossAxisAlignment.start,
+       children: [
+         Row(
+           children: [
+             Icon(
+               icon,
+               color: theme.colorScheme.primary,
+               size: 24,
+             ),
+             const SizedBox(width: 12),
+             Text(
+               title,
+               style: GoogleFonts.poppins(
+                 fontSize: 20,
+                 fontWeight: FontWeight.w600,
+                 color: theme.colorScheme.onSurface,
+               ),
+             ),
+           ],
+         ),
+         const SizedBox(height: 16),
+         ...children,
+       ],
+     );
+   }
+ 
+   Widget _buildInfoCard(String title, String value, IconData icon, Color color) {
+     return Container(
+       padding: const EdgeInsets.all(16),
+       decoration: BoxDecoration(
+         color: color.withOpacity(0.1),
+         borderRadius: BorderRadius.circular(12),
+         border: Border.all(
+           color: color.withOpacity(0.2),
+           width: 1,
+         ),
+       ),
+       child: Row(
+         children: [
+           Icon(
+             icon,
+             color: color,
+             size: 20,
+           ),
+           const SizedBox(width: 12),
+           Expanded(
+             child: Column(
+               crossAxisAlignment: CrossAxisAlignment.start,
+               children: [
+                 Text(
+                   title,
+                   style: GoogleFonts.poppins(
+                     fontSize: 12,
+                     fontWeight: FontWeight.w500,
+                     color: color,
+                   ),
+                 ),
+                 Text(
+                   value,
+                   style: GoogleFonts.poppins(
+                     fontSize: 14,
+                     fontWeight: FontWeight.w400,
+                   ),
+                 ),
+               ],
+             ),
+           ),
+         ],
+       ),
+     );
+   }
+ }
```

---

Maintenant, nous devons créer le fichier audio de test et modifier l'application principale pour intégrer l'overlay des notifications. Commençons par créer le dossier assets :

---

```bash
mkdir -p assets/audio
```

```
workspace $workspace $ 

```

---

Créons un fichier audio simple pour le test (un fichier bip court) :

---

```bash
echo "Fichier audio de test - remplacez par un vrai fichier .mp3" > assets/audio/bling.mp3
```

```
workspace $workspace $ 

```

---

Maintenant, mettons à jour le pubspec.yaml pour inclure les assets :

---



---

Maintenant, modifions l'application principale pour intégrer l'overlay des notifications. Regardons d'abord le router :

---

Read file: lib/core/providers/router_provider.dart

---

Maintenant, ajoutons la route pour la page de test des notifications :

---



---



---



---

Maintenant, modifions le main.dart pour intégrer l'overlay de notifications :

---



---



---

Maintenant, ajoutons un bouton pour accéder à la page de test dans la page d'accueil. Regardons d'abord la page d'accueil :

---

<details>
            <summary>Searched codebase "home_page.dart" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: lib/ui/pages/home_page.dart

---

Read file: lib/ui/pages/home_page.dart

---

Maintenant, cherchons une partie de la page où nous pouvons ajouter un bouton de test. Regardons le reste de la page :

---

Read file: lib/ui/pages/home_page.dart

---

Maintenant, modifions la page d'accueil pour ajouter un bouton d'accès discret à la page de test. Je vais l'ajouter dans le footer :

---

Read file: lib/ui/pages/home_page.dart

---

Ajoutons un bouton discret pour accéder aux tests de notifications. Je vais le placer dans le footer :

---



---

Il faut aussi ajouter l'import pour AppRoutes :

---



---

L'import est déjà inclus. Maintenant, nous devons corriger le service de notifications pour utiliser l'URL dynamique depuis SharedPreferences. Modifions-le :

---



---



---

Maintenant, créons un fichier de documentation pour expliquer l'utilisation du système :

---

```diff
+ # 🔊 Système de Notifications Vocales Interactives
+ 
+ ## 📋 Vue d'ensemble
+ 
+ Le système de notifications vocales interactives permet à l'application Flutter de recevoir et diffuser automatiquement des notifications avec audio depuis une API Flask, sans utiliser les notifications natives du système.
+ 
+ ## 🏗️ Architecture
+ 
+ ### Composants principaux
+ 
+ 1. **NotificationModel** (`lib/core/models/notification_model.dart`)
+    - Modèle de données pour les notifications
+    - Gère la sérialisation/désérialisation JSON
+ 
+ 2. **NotificationService** (`lib/core/providers/notification_service.dart`)
+    - Service principal de gestion des notifications
+    - Polling régulier de l'API Flask
+    - Lecture audio automatique
+    - Gestion du cache pour éviter les doublons
+ 
+ 3. **VoiceNotificationCard** (`lib/ui/widgets/voice_notification_card.dart`)
+    - Widget de carte de notification avec animations
+    - Design moderne avec effets visuels
+ 
+ 4. **NotificationOverlay** (`lib/ui/widgets/notification_overlay.dart`)
+    - Overlay global pour afficher les notifications
+    - Gestion automatique de l'affichage et du dismiss
+ 
+ 5. **NotificationTestPage** (`lib/ui/pages/notification_test_page.dart`)
+    - Interface de test et configuration
+    - Contrôles pour démarrer/arrêter le polling
+ 
+ ## 🚀 Fonctionnalités
+ 
+ ### ✅ Implémentées
+ 
+ - **Polling automatique** : Vérification régulière des nouvelles notifications (configurable, par défaut 10s)
+ - **Détection des doublons** : Système de cache basé sur les timestamps
+ - **Lecture audio séquentielle** : Bip d'alerte + message vocal distant
+ - **Interface utilisateur non-bloquante** : Notifications flottantes au-dessus du contenu
+ - **Animations fluides** : Effets slide-in et fade-in pour l'apparition
+ - **Configuration dynamique** : URL de l'API modifiable dans l'interface
+ - **Auto-dismiss** : Disparition automatique après 8 secondes
+ - **Gestion multi-notifications** : Support de plusieurs notifications simultanées
+ 
+ ### 🎵 Gestion Audio
+ 
+ 1. **Son d'alerte** : Court bip depuis `assets/audio/bling.mp3`
+ 2. **Message vocal** : Streaming du fichier MP3 distant depuis l'API Flask
+ 3. **Lecture séquentielle** : Alerte → Pause (500ms) → Message vocal
+ 
+ ## 🔧 Configuration
+ 
+ ### URL de l'API Flask
+ 
+ L'application se connecte à votre API Flask via l'URL configurée dans l'interface de test.
+ 
+ **Endpoint attendu** : `GET /notifications/`
+ 
+ **Format de réponse JSON** :
+ ```json
+ [
+   {
+     "audio_file": "audio_files/notification_1752911454.mp3",
+     "message": "Votre plantation est saine pour l'instant.",
+     "timestamp": 1752911454,
+     "titre": "Analyse automatique"
+   }
+ ]
+ ```
+ 
+ ### Fichiers audio
+ 
+ - **Alerte locale** : `assets/audio/bling.mp3` (inclus dans l'app)
+ - **Messages vocaux** : Servis depuis l'API Flask via `/{audio_file}`
+ 
+ ## 🎯 Utilisation
+ 
+ ### Accès à l'interface de test
+ 
+ 1. Lancez l'application Flutter
+ 2. Depuis la page d'accueil, cliquez sur le bouton discret "Test Notifications" en bas
+ 3. Configurez l'URL de votre API Flask
+ 4. Démarrez le polling
+ 
+ ### Configuration recommandée
+ 
+ ```
+ URL de base : http://192.168.1.100:5000
+ Polling : 10 secondes
+ Auto-dismiss : 8 secondes
+ ```
+ 
+ ### Commandes disponibles
+ 
+ - **Démarrer/Arrêter le polling** : Active ou désactive la surveillance
+ - **Test notification** : Simule une notification (sans audio réel)
+ - **Vider le cache** : Remet à zéro les notifications déjà traitées
+ - **Sauvegarder la configuration** : Persiste l'URL de l'API
+ 
+ ## 🔄 Cycle de vie
+ 
+ 1. **Démarrage automatique** : Le polling démarre au lancement de l'app
+ 2. **Polling continu** : Vérification régulière de l'endpoint
+ 3. **Détection** : Nouvelles notifications identifiées par timestamp
+ 4. **Affichage** : Apparition animée de la carte de notification
+ 5. **Audio** : Lecture automatique bip + message vocal
+ 6. **Dismiss** : Disparition automatique ou manuelle
+ 
+ ## 🎨 Personnalisation
+ 
+ ### Animations
+ 
+ Les animations peuvent être personnalisées dans `VoiceNotificationCard` :
+ - **Slide-in** : Configuration via `flutter_animate`
+ - **Pulsation de l'icône** : Animation en boucle pour attirer l'attention
+ - **Transitions** : Durées et courbes modifiables
+ 
+ ### Styles visuels
+ 
+ - **Couleurs** : Adaptées au thème de l'application
+ - **Typographie** : Google Fonts (Poppins)
+ - **Icônes** : Phosphor Icons pour la cohérence
+ - **Ombres** : Effets de profondeur multicouches
+ 
+ ## 🛠️ Dépendances requises
+ 
+ ```yaml
+ dependencies:
+   just_audio: ^0.9.36          # Lecture audio
+   flutter_animate: ^4.5.0      # Animations
+   dio: ^5.4.1                  # Requêtes HTTP
+   shared_preferences: ^2.2.2   # Persistance locale
+   google_fonts: ^6.2.1         # Typographie
+   phosphor_flutter: ^2.1.0     # Icônes
+   flutter_riverpod: ^2.5.1     # Gestion d'état
+ ```
+ 
+ ## 🔍 Debug et Tests
+ 
+ ### Logs de debug
+ 
+ Le service affiche des logs pour le diagnostic :
+ ```
+ Démarrage du polling des notifications...
+ Nouvelle notification reçue: Analyse automatique
+ Lecture du message vocal: http://192.168.1.100:5000/audio_files/notification_1752911454.mp3
+ ```
+ 
+ ### Test sans backend
+ 
+ La page de test permet de simuler des notifications même sans API Flask active.
+ 
+ ## 🚨 Gestion d'erreurs
+ 
+ - **Connexion réseau** : Échecs silencieux avec logs
+ - **Fichiers audio manquants** : Tentative de lecture avec gestion d'erreur
+ - **JSON malformé** : Validation et traitement des erreurs
+ - **Permissions audio** : Gestion automatique par `just_audio`
+ 
+ ## 🔐 Sécurité et Performance
+ 
+ - **Cache local** : Timestamps stockés dans SharedPreferences
+ - **Polling optimisé** : Arrêt automatique lors de la fermeture de l'app
+ - **Gestion mémoire** : Disposal correct des AudioPlayer
+ - **Ressources** : Nettoyage automatique des contrôleurs d'animation
+ 
+ ## 🎯 Points d'extension
+ 
+ 1. **Notifications riches** : Ajout d'images, boutons d'action
+ 2. **Persistence** : Historique des notifications reçues
+ 3. **Filtrage** : Critères de priorité ou catégories
+ 4. **Interactions** : Actions personnalisées sur tap/swipe
+ 5. **Synthèse vocale** : TTS local en fallback du MP3 distant
+ 
+ ---
+ 
+ **Note** : Ce système est conçu pour être léger, non-intrusif et facilement désactivable selon les besoins de l'utilisateur.
```

---

Maintenant, créons un exemple de backend Flask simple pour tester le système :

---

```diff
+ #!/usr/bin/env python3
+ """
+ Exemple de serveur Flask pour tester le système de notifications vocales
+ Ce serveur génère des notifications de test avec des fichiers audio simulés.
+ """
+ 
+ from flask import Flask, jsonify, send_file
+ from flask_cors import CORS
+ import time
+ import os
+ import random
+ 
+ app = Flask(__name__)
+ CORS(app)  # Permettre les requêtes cross-origin depuis Flutter
+ 
+ # Données de test
+ NOTIFICATION_EXAMPLES = [
+     {
+         "titre": "Analyse automatique",
+         "message": "Votre plantation de tomates présente un excellent état de santé.",
+     },
+     {
+         "titre": "Alerte ravageurs",
+         "message": "Détection de pucerons sur la parcelle nord. Intervention recommandée.",
+     },
+     {
+         "titre": "Optimisation irrigation",
+         "message": "Le sol de la zone sud nécessite un arrosage dans les 2 prochaines heures.",
+     },
+     {
+         "titre": "Météo favorable",
+         "message": "Conditions optimales pour la plantation prévues demain matin.",
+     },
+     {
+         "titre": "Récolte recommandée",
+         "message": "Les tomates de la parcelle est ont atteint leur maturité optimale.",
+     }
+ ]
+ 
+ # Stockage temporaire des notifications générées
+ generated_notifications = []
+ 
+ @app.route('/notifications/', methods=['GET'])
+ def get_notifications():
+     """
+     Endpoint principal pour récupérer les notifications
+     Génère occasionnellement de nouvelles notifications pour le test
+     """
+     global generated_notifications
+     
+     # Générer une nouvelle notification aléatoirement (20% de chance)
+     if random.random() < 0.2:
+         generate_new_notification()
+     
+     return jsonify(generated_notifications)
+ 
+ @app.route('/audio_files/<filename>', methods=['GET'])
+ def get_audio_file(filename):
+     """
+     Sert les fichiers audio (simulés pour le test)
+     En production, ceci devrait servir de vrais fichiers MP3
+     """
+     # Pour le test, on retourne un fichier audio vide ou un placeholder
+     # En production, remplacez ceci par le vrai fichier audio
+     try:
+         # Créer un fichier audio de test s'il n'existe pas
+         audio_dir = 'audio_files'
+         if not os.path.exists(audio_dir):
+             os.makedirs(audio_dir)
+         
+         file_path = os.path.join(audio_dir, filename)
+         if not os.path.exists(file_path):
+             # Créer un fichier audio de test vide
+             with open(file_path, 'wb') as f:
+                 f.write(b'')  # Fichier vide pour le test
+         
+         return send_file(file_path, mimetype='audio/mpeg')
+     except Exception as e:
+         return jsonify({"error": f"Fichier audio non trouvé: {filename}"}), 404
+ 
+ @app.route('/generate_notification', methods=['POST'])
+ def generate_notification_manual():
+     """
+     Endpoint pour générer manuellement une notification (utile pour les tests)
+     """
+     generate_new_notification()
+     return jsonify({"message": "Nouvelle notification générée"})
+ 
+ @app.route('/clear_notifications', methods=['POST'])
+ def clear_notifications():
+     """
+     Vide toutes les notifications (utile pour les tests)
+     """
+     global generated_notifications
+     generated_notifications = []
+     return jsonify({"message": "Notifications effacées"})
+ 
+ @app.route('/status', methods=['GET'])
+ def get_status():
+     """
+     Endpoint de statut pour vérifier que le serveur fonctionne
+     """
+     return jsonify({
+         "status": "running",
+         "notifications_count": len(generated_notifications),
+         "timestamp": int(time.time())
+     })
+ 
+ def generate_new_notification():
+     """
+     Génère une nouvelle notification avec un timestamp unique
+     """
+     global generated_notifications
+     
+     # Choisir un exemple aléatoire
+     example = random.choice(NOTIFICATION_EXAMPLES)
+     
+     # Créer la notification avec timestamp unique
+     timestamp = int(time.time()) + random.randint(0, 10)  # Éviter les doublons
+     audio_filename = f"notification_{timestamp}.mp3"
+     
+     notification = {
+         "audio_file": f"audio_files/{audio_filename}",
+         "message": example["message"],
+         "timestamp": timestamp,
+         "titre": example["titre"]
+     }
+     
+     # Ajouter à la liste (garder seulement les 10 dernières)
+     generated_notifications.append(notification)
+     if len(generated_notifications) > 10:
+         generated_notifications.pop(0)
+     
+     print(f"📢 Nouvelle notification générée: {example['titre']}")
+ 
+ @app.route('/', methods=['GET'])
+ def index():
+     """
+     Page d'accueil avec informations sur l'API
+     """
+     return """
+     <h1>🔊 Serveur de Notifications Vocales</h1>
+     <h2>Endpoints disponibles:</h2>
+     <ul>
+         <li><code>GET /notifications/</code> - Récupérer les notifications</li>
+         <li><code>GET /audio_files/&lt;filename&gt;</code> - Télécharger un fichier audio</li>
+         <li><code>POST /generate_notification</code> - Générer une notification manuellement</li>
+         <li><code>POST /clear_notifications</code> - Effacer toutes les notifications</li>
+         <li><code>GET /status</code> - Statut du serveur</li>
+     </ul>
+     <h2>Configuration Flutter:</h2>
+     <p>URL de base: <code>http://localhost:5000</code></p>
+     <p>Notifications actives: <strong>{}</strong></p>
+     """.format(len(generated_notifications))
+ 
+ if __name__ == '__main__':
+     print("🚀 Démarrage du serveur de notifications vocales...")
+     print("📱 Configurez Flutter avec l'URL: http://localhost:5000")
+     print("🔄 Les notifications sont générées aléatoirement toutes les ~50 secondes")
+     
+     # Générer une notification initiale pour le test
+     generate_new_notification()
+     
+     app.run(host='0.0.0.0', port=5000, debug=True)
```

---

Finalement, créons un fichier requirements.txt pour le serveur Flask :

---

```diff
+ Flask==2.3.3
+ Flask-CORS==4.0.0
```

---

Enfin, créons un guide de démarrage rapide :

---

```diff
+ # 🚀 Guide de Démarrage Rapide - Notifications Vocales
+ 
+ ## ⚡ Test rapide en 5 minutes
+ 
+ ### 1. Démarrer le serveur Flask de test
+ 
+ ```bash
+ # Installer les dépendances
+ pip install -r requirements.txt
+ 
+ # Démarrer le serveur
+ python backend_flask_exemple.py
+ ```
+ 
+ Le serveur démarre sur `http://localhost:5000`
+ 
+ ### 2. Configurer l'application Flutter
+ 
+ 1. Lancez l'application Flutter
+ 2. Sur la page d'accueil, cliquez sur **"Test Notifications"** (bouton discret en bas)
+ 3. Dans le champ "URL de base", entrez : `http://localhost:5000`
+ 4. Cliquez sur **"Sauvegarder la configuration"**
+ 
+ ### 3. Démarrer les notifications
+ 
+ 1. Cliquez sur **"Démarrer le polling"**
+ 2. Le système commence à vérifier les notifications toutes les 10 secondes
+ 3. Le serveur Flask génère aléatoirement des notifications de test
+ 
+ ### 4. Observer le fonctionnement
+ 
+ - **Notifications automatiques** : Apparaissent de manière aléatoire
+ - **Animations** : Cartes qui glissent depuis le haut
+ - **Audio** : Bip d'alerte + tentative de lecture du message vocal
+ - **Auto-dismiss** : Disparition automatique après 8 secondes
+ 
+ ## 🔧 Commandes de test utiles
+ 
+ ### Générer une notification manuellement
+ ```bash
+ curl -X POST http://localhost:5000/generate_notification
+ ```
+ 
+ ### Vérifier le statut du serveur
+ ```bash
+ curl http://localhost:5000/status
+ ```
+ 
+ ### Voir les notifications actuelles
+ ```bash
+ curl http://localhost:5000/notifications/
+ ```
+ 
+ ### Effacer toutes les notifications
+ ```bash
+ curl -X POST http://localhost:5000/clear_notifications
+ ```
+ 
+ ## 📱 Interface de test Flutter
+ 
+ ### Contrôles disponibles
+ 
+ - **🟢 Démarrer le polling** : Active la surveillance
+ - **🟠 Arrêter le polling** : Désactive la surveillance  
+ - **🧪 Test notification** : Simule une notification locale
+ - **🗑️ Vider le cache** : Remet à zéro l'historique
+ - **💾 Sauvegarder** : Persiste la configuration
+ 
+ ### Informations affichées
+ 
+ - Intervalle de polling : 10 secondes
+ - Endpoint : `/notifications/`
+ - Fichier audio d'alerte : `assets/audio/bling.mp3`
+ 
+ ## 🐛 Dépannage
+ 
+ ### L'application ne reçoit pas de notifications
+ 
+ 1. Vérifiez que le serveur Flask fonctionne : `http://localhost:5000/status`
+ 2. Confirmez l'URL dans l'app Flutter
+ 3. Vérifiez les logs de debug dans la console Flutter
+ 4. Testez l'endpoint manuellement : `curl http://localhost:5000/notifications/`
+ 
+ ### Pas de son d'alerte
+ 
+ 1. Vérifiez que le fichier `assets/audio/bling.mp3` existe
+ 2. Confirmez que les assets sont déclarés dans `pubspec.yaml`
+ 3. Redémarrez l'application après modification des assets
+ 
+ ### Erreurs de lecture audio des messages vocaux
+ 
+ - Normal avec le serveur de test (fichiers audio vides)
+ - En production, remplacez par de vrais fichiers MP3
+ - Les erreurs sont journalisées sans planter l'app
+ 
+ ## 📦 Production
+ 
+ ### Pour utiliser avec votre vraie API Flask
+ 
+ 1. Remplacez l'URL dans l'interface de test
+ 2. Assurez-vous que votre API retourne le format JSON attendu
+ 3. Vérifiez que les fichiers MP3 sont accessibles via HTTP
+ 4. Activez CORS sur votre serveur Flask
+ 
+ ### Format JSON requis
+ 
+ ```json
+ [
+   {
+     "audio_file": "audio_files/notification_1752911454.mp3",
+     "message": "Votre plantation est saine pour l'instant.",
+     "timestamp": 1752911454,
+     "titre": "Analyse automatique"
+   }
+ ]
+ ```
+ 
+ ### Structure des fichiers audio
+ 
+ ```
+ votre_serveur_flask/
+ ├── audio_files/
+ │   ├── notification_1752911454.mp3
+ │   ├── notification_1752911455.mp3
+ │   └── ...
+ └── app.py
+ ```
+ 
+ ## 🎯 Personnalisation
+ 
+ ### Modifier l'intervalle de polling
+ 
+ Dans `lib/core/constants/api_constants.dart` :
+ ```dart
+ static const Duration pollingInterval = Duration(seconds: 5); // 5 secondes
+ ```
+ 
+ ### Changer la durée d'auto-dismiss
+ 
+ Dans `lib/ui/widgets/notification_overlay.dart` :
+ ```dart
+ Timer(const Duration(seconds: 12), () {  // 12 secondes
+   _dismissNotification(notification);
+ });
+ ```
+ 
+ ### Personnaliser les animations
+ 
+ Dans `lib/ui/widgets/voice_notification_card.dart`, modifiez :
+ ```dart
+ .slideY(
+   begin: -1.0,
+   end: 0.0,
+   duration: 800.ms,  // Plus lent
+   curve: Curves.bounceOut,  // Effet rebond
+ )
+ ```
+ 
+ ---
+ 
+ **🎉 Félicitations !** Votre système de notifications vocales est maintenant opérationnel.
```

---

Parfait ! J'ai maintenant implémenté un système complet de notifications vocales interactives pour votre application Flutter. Voici un résumé de ce qui a été créé :

## 🎯 **Système de Notifications Vocales Implémenté**

### ✅ **Fonctionnalités réalisées :**

1. **Polling automatique** vers l'API Flask (configurable, défaut : 10s)
2. **Détection intelligente** des nouvelles notifications via timestamps
3. **Interface UI non-native** avec cartes animées flottantes
4. **Lecture audio séquentielle** : bip d'alerte + message vocal distant
5. **Animations fluides** : slide-in, fade-in, pulsation d'icône
6. **Gestion des doublons** via cache local persistant
7. **Configuration dynamique** de l'URL API dans l'interface
8. **Auto-dismiss** après 8 secondes
9. **Interface de test** complète avec contrôles

### 📁 **Fichiers créés :**

**Flutter :**
- `lib/core/models/notification_model.dart` - Modèle de données
- `lib/core/constants/api_constants.dart` - Configuration API
- `lib/core/providers/notification_service.dart` - Service principal
- `lib/ui/widgets/voice_notification_card.dart` - Widget de notification
- `lib/ui/widgets/notification_overlay.dart` - Overlay global
- `lib/ui/pages/notification_test_page.dart` - Interface de test
- `assets/audio/bling.mp3` - Son d'alerte (placeholder)

**Backend de test :**
- `backend_flask_exemple.py` - Serveur Flask de démonstration
- `requirements.txt` - Dépendances Python

**Documentation :**
- `NOTIFICATIONS_VOCALES.md` - Documentation technique complète
- `GUIDE_DEMARRAGE_NOTIFICATIONS.md` - Guide de démarrage rapide

### 🚀 **Comment tester :**

1. **Démarrer le serveur Flask :**
   ```bash
   pip install -r requirements.txt
   python backend_flask_exemple.py
   ```

2. **Configurer Flutter :**
   - Lancer l'app Flutter
   - Page d'accueil → clic sur "Test Notifications"
   - URL de base : `http://localhost:5000`
   - Démarrer le polling

3. **Observer :**
   - Notifications aléatoires toutes les ~50 secondes
   - Cartes animées qui apparaissent en haut
   - Tentative de lecture audio (bip + message vocal)

### 🎨 **Caractéristiques techniques :**

- **Architecture** : Riverpod + Streams pour la réactivité
- **Audio** : `just_audio` pour la lecture locale et distante
- **Animations** : `flutter_animate` pour les effets visuels
- **Persistance** : `SharedPreferences` pour la configuration et le cache
- **Réseau** : `Dio` pour les requêtes HTTP
- **UI** : Design moderne avec Google Fonts et Phosphor Icons

Le système est prêt à être utilisé et facilement personnalisable selon vos besoins spécifiques ! 🎉

---

```diff
- 
+ Fichier audio de test - remplacez par un vrai fichier .mp3
+ 
```

---



---

